# 问题多多的直流减速电机控制系统的制作历程

        抱着试试看的心态，我开始了直流减速电机控制系统的制作。该系统的主要实现功能如下：

（1） 完成电机驱动板的制作。

（2） 采集其转速与角度数据，在屏幕上实时显示（比如：OLED）；

（3） 控制电机的转速以正弦函数的规律变化，其中正弦函数的周期 2S，在上位机上绘制出电机目标转速和实际转速的曲线；

（4） 以无线的方式调整电机控制参数，包括目标转速、目标角度和 PID。

下面分部分叙述并总结我的制作过程和心路历程。

## 电机驱动

### 电机驱动芯片介绍

        该部分使用TB6612FNG芯片和外加电源滤波电容电路作为电机驱动的基本电路。TB6612FNG芯片的引脚图和内部功能模块见下图所示：

<img src="file:///C:/Users/30187/AppData/Roaming/marktext/images/2021-05-02-22-44-41-image.png" title="" alt="" data-align="center">

上图中主要逻辑功能引脚说明见下表所示：

| 引脚      | 逻辑功能           |
| ------- |:--------------:|
| VM1/2/3 | 电机驱动电源         |
| VCC     | 电路逻辑电源         |
| PWMA    | A通道PWM内部下拉输入引脚 |
| AIN1    | A通道内部下拉输入引脚1   |
| AIN2    | A通道内部下拉输入引脚2   |
| AO1     | A通道输出引脚1       |
| AO2     | A通道输出引脚2       |
| GND     | 地              |

输入输出引脚高低电平对应关系与工作模式见下表所示：

|      | 输入   |      |     | 输出  |      |
|:----:|:----:|:----:|:---:|:---:|:----:|
| PWMA | AIN1 | AIN2 | AO1 | AO2 | Mode |
| H    | H    | L    | H   | L   | 正转   |
| H    | L    | H    | L   | H   | 反转   |
| H    | L    | L    | OFF | OFF | 停止   |
| L    | X    | X    | L   | L   | 制动   |

使用此电机驱动模块时，输入的PWMA，AIN1，AIN2分别与STM32单片机定义的引脚连接，输出的AO1，AO2与电机的M+，M-引脚连接。

### 电机调速原理简述

        该段内容结合网上解释和我个人理解，仅为个人学习所得。该部分采用脉冲宽度调制（PWM）方式来改变电机转速。PWM是一种用数字信号来控制模拟电路的技术。该方式的数学描述为：假如我们需要让电机转速以正弦规律变化，那么我们就需要让驱动电机的功率大小或者说是电压大小以正弦规律变化。那么以半个周期的正弦波形为例，我们首先将正弦波形分为N份宽度相同即▲t相等，幅值不相等的脉冲波形；再将这N份脉冲波形转换成幅度相等、宽度不相等的矩形脉冲波形，转换的标准是转换后的矩形脉冲的面积与转换前的脉冲波形的面积相等即达到相同的效果。转换后所得的矩形脉冲波形即为PWM波形，其与该半个周期的正弦波形是等效的。同理可得正弦负半周的PWM波形。那么我们可以知道：通过改变矩形脉冲的宽度即占空比就可以改变由PWM波形信号控制的开关器件的通断时间，进而控制PWM逆变电路的输出电压的幅值大小。

        该方式的具体实现为：通过STM32输出引脚输出高低电平即数字信号给TB6612的PWMA引脚即PWM输入引脚，而输出高低电平的频率和占空比由STM32的定时器决定。开始时我们即设定好PWM的输出频率，再在电机转动过程中间隔一定时间就改变PWM占空比，且占空比的取值能使电机的驱动电压也即最终电机转速按照正弦规律变化。这种幅度和频率相等，占空比随正弦规律变化的脉冲调制方式又称为SPWM法。

## 编码器采集电机转速

         该模块使用增量式光电编码器来实现。光电编码器是一种通过光电转换将输出轴上的机械几何位移量转换成脉冲或数字量的传感器。光电编码器是由光码盘和光电检测装置组成。光码盘是在一定直径的圆板上等分地开通若干个长方形孔。由于光电码盘与电动机同轴，电动机旋转时，检测装置检测输出若干脉冲信号，为判断转向，一般输出两组存在一定相位差的方波信号。 本系统使用的编码器实物见下图所示：

<img src="file:///C:/Users/30187/AppData/Roaming/marktext/images/2021-05-03-21-49-51-image.png" title="" alt="" data-align="center">

        根据上图的接线说明可以看到，我们只需给编码器电源5V供电，在电机转动的时候即可通过 AB 相输出方波信号。编码器自带了上拉电阻，所以无需外部上拉，可以直接连接到单片机 IO 读取。且由于STM32定时器自带编码器模式，可实现硬件四倍频以提高编码器的测量精度，容许接口出现抖动而不影响结果。故本模块使用上述编码器配合STM32定时器的编码器模式来采集脉冲个数从而计算电机转速。

         那么现在的问题是：单片机是如何对输入的脉冲个数进行计数，又是如何根据AB相脉冲的相位差判断电机转动方向的？

        对于前一个问题，我们可以查找STM32中文参考手册中关于定时器编码器接口模式的功能描述。作为对自我学习情况的总结，在此附上我个人理解：

以计数器同时在TI1和TI2边沿计数为例，首先配置定时器的编码器模式为：

| 定时器编码器模式配置            |
| --------------------- |
| IC1FP1映射到TI1          |
| IC2FP2映射到TI2          |
| IC1FP1不反相， IC1FP1=TI1 |
| IC2FP2不反相， IC2FP2=TI2 |
| 上升沿和下降沿均计数            |

然后我们来看下表---计数方向与编码器信号的关系：

| 有效边沿        | 相对信号的电平  (TI1FP1对应TI2,   TI2FP2对应TI1) | TI1FP1信号 | TI1FP1信号 | TI2FP2信号 | TI2FP2信号 |
|:-----------:|:-------------------------------------:|:--------:|:--------:|:--------:|:--------:|
|             |                                       | 上升       | 下降       | 上升       | 下降       |
| 在TI1和TI2上计数 | 高                                     | 向下计数     | 向上计数     | 向上计数     | 向下计数     |
| 在TI1和TI2上计数 | 低                                     | 向上计数     | 向下计数     | 向下计数     | 向上计数     |

再来根据上表说明来看下图---编码器模式下的计数器操作实例：

![](C:\Users\30187\AppData\Roaming\marktext\images\2021-05-04-00-22-54-image.png)

图为向上计数和向下计数的两个情况说明，其他计数情况均可与上表对应。

         因此，当我们间隔一段时间读取计数值时，计数值始终在0~ARR之间取值，且通过读取TIMx_CR1的DIR位来确定计数方向为向上还是向下计数，从而可以计算电机转速和判断电机转动方向。

        然而，在我参照商家例程时发现它并没有读取DIR位来判断计数方向，而是通过下面两行代码来读取编码器计数值并判断计数方向。

```c
int encoder;   //编码器计数值
Encoder = (short)ENCODER_TIM->CNT;   //读取计数
```

首先来看一下数据类型：

| 类型说明符 | 类型名 | 字节数 | 数的范围               |
|:-----:|:---:|:---:|:------------------:|
| int   | 整型  | 4   | 有符数：-2^31~(2^31-1) |
| short | 短整型 | 2   | 有符数：-2^15~(2^15-1) |

。。。。。。。。。。。。。。。。。。。。好吧，在我surf the internet很久后，发现了多种对强制类型转换的解释后，包括概括性的和深入到计算机数据存储所用补码的，我发现我傻了。。。短时间应该总结不出自己的理解来了。。。所以这里我先空着，等放段时间再看时说不定能豁然开朗呢？（是我多想了。。。）

还是先说说我遇到的问题，对这个我可以说出一箩筐：

1.在没有完全弄清楚编码器模式的情况下，开始了编码器的使用与调试。。。相当于地基都没有打牢的情况下建房并交付使用。结果可想而知，没碰到问题是运气好，碰到问题那是极大概率事件，且不会对问题进行分析与正确有效地予以解决也是必然现象。

2.所以问题来了：在上位机绘制电机转速波形也即为实时采样的编码器脉冲计数值，会突然跳到其变量类型规定的数值范围的最大值。比如设定的uint32_t encoder为计数变量，则其值会跳到2^32=4,294,967,296。。。对此我的分析：

可能原因之一：由于在之前单独测试电机转速曲线时一切正常，之后加上pid算法后，出现了这种问题，所以我判断是pid算法在对电机进行转速调节时导致电机反转而出现上述问题。所以我在pid参数上下功夫。。。但由于对编码器和pid算法都是初次使用，且在没有对其完全了解的情况下就盲目使用，导致波形时好时坏，可能今天是好的，明天同样的代码却不行。而且出现问题也不能准确分析和有效解决。。。所以啊，在应用一个产品时，首先要花时间认真弄清楚它的工作原理，不能似是而非，似懂非懂。这样在真正应用它时，首先是本来就像蒙住了一层纱一样地看不清它每一个工作状态背后的机理，而且碰到问题也是很正常的，并且会感觉到费力不讨好，花了时间却分析不出问题的关键点，问题也就不会被真正有效解决。其次，在碰到问题时，才是真正显示一个人的能力水平和心理素质的时候，你必须有牢固的技术基础和强大的心理素质，分析各种可能的原因并逐一找到测试方法并实施，在不断排除的过程中，找到问题的所在。当然，这一切都要建立在你明晰它的工作原理和工作情况的条件下才能做到。所以我失败了。。。

可能原因之二：这个原因是我在此时写总结的时候，由于问题没有解决而导致总结知识点时难以进行下去。于是我又重新回到代码，发现了我的变量的数据类型定义有问题，而在这之前，我对变量的数据类型并没有充分了解与分析，因此对变量的类型定义并没有给予重视。在main.c中我定义了`uint32_t encoder;//编码器脉冲计数` 要知道这里是一个无符号的整形变量，其32位均用来表示数值大小。而在读取编码器脉冲计数的函数中我定义的是`int encoder;` 这里的int类型则默认为32位有符整型。而通过代码`encoder = (short)ENCODER_TIM->CNT;` 将CNT寄存器中的16位无符数值转换为有符数值并强制类型转换后赋给encoder，我们想的是encoder是一个有符号数据，但是encoder被定义成一个uint32_t即无符32位整型变量。。。总而言之，从CNT寄存器中数值到encoder经历了：*无符16位→有符16位→有符32位→无符32位* 。好吧，这里我也只能这样对现象进行描述而做不到对其进行进一步分析，因此我的数据类型转换这个知识点还需要进一步研究。。。而且这些都是我此时写总结的时候发现的，还没有验证，没准又是下一个被排除的可能原因。。。但发现问题总比没发现问题更让人有所期待。。。

        这将完未完的编码器暂且说到这儿吧。。。

## 上位机转速曲线描绘

        对于这一部分，相当于是直接移植商家例程而来，我花的时间不长。也正因是移植现有程序，我对这部分的分析理解也仅限于对代码的阅读知晓其各函数功能以便于移植，而其内部机理我无法过多阐述。。。

---



下面的所有部分都是我没能实现的部分，暂时搭个框架吧。没有真正利用所学解决遇到的问题，我是真的写不出来。。。就当记录一下自己事倍功半的傻子历程吧。

## OLED显示转速信息

        这部分使用的0.96’OLED(4Pin)采用 SSD1306 为主芯片，像素为 128*64，通讯方式为 IIC，地址可选（默认地址0x78），接口简单，模块带有稳压芯片，支持3.3V~5V电压供电，上电自动复位。

### OLED显示中文字模

        由于之前没有尝试过用OLED显示中文字模，所以这次尝试了一下。。。

在阅读完oled例程和上网搜索了相关信息后，我利用中文字模生成软件生成了自己的中文字模库。在这一过程中，对软件的使用和OLED显示像素有了初步了解。

        首先是对软件的使用方面。在粗浅地阅读例程后，其实我对OLED显示原理地理解是肤浅的，对OLED中文字模显示的细节方面缺乏真正的认识，对下图中的选项具体设置的是OLED显示的哪些方面是不清楚的，尤其是取模方式、取模走向，而这直接影响输出的字模数组的元素数值。在初次尝试生成所需字模失败后，我用软件生成了例程中所给字模，发现二者的字模数组的元素并不相同。。。在请教同学后，才知道在生成字模前要设置相关信息，也就是下图中的字模选项的配置。而再看例程时，我发现例程中字模数组是有注释说明的，且正是其相关配置。。。于是我更改下图选项后，就成功生成了所需字模。。。有时候，与其自己在那儿琢磨半天还搞不定，还不如他人一句话的功夫来的快。。。

<img src="file:///C:/Users/30187/AppData/Roaming/marktext/images/2021-05-06-22-08-02-image.png" title="" alt="" data-align="center">

### OLED实时显示电机转速

        这部分也是我初次学习和应用，且并没有成功实现所需功能。。。I AM SO VEGETABLE！还是先做个小总结吧。。。

        因为没有现有例程可供参考学习，所以我主要是通过看他人博客来学习。我的个人感受：个人博客是基于自身学习情况和结合个人理解所得，单看一家容易片面，多看几篇就当局者迷了，尤其对于初次接触学习的东西。至少对我自己是这样的。

 结合多家所长，我最终在定时器中断函数中编写了下列代码。。。

```c
if(c2==10)
{
	//printf("\r\n\r\n333333333333333333333\r\n\r\n");
	OLED_SetPos(0,0);
	//printf("\r\n\r\n444444444444444444444\r\n\r\n");
	for(i=0;i<4;i++)
	{
		Oled_Output_Buffer[i] = (encoder>>(8*(3-i)))&0xFF;
	}
	//printf("\r\n\r\n55555555555555555555\r\n\r\n");
	IIC1_DMA_TX(Oled_Output_Buffer, 4);
	DelayS(1);
	//printf("\r\n\r\n66666666666666666666\r\n\r\n");
		
	c2=0;
}
```

其中调用的函数`IIC1_DMA_TX(Oled_Output_Buffer, 4);` 的定义如下：

```c
void IIC1_DMA_TX(uint8_t *tx_buffer,uint16_t length)
{
    DMA_Cmd(IIC1_TX_DMA_CHANNEL, DISABLE);     //关闭DMA通道
    DMA_SetCurrDataCounter(IIC1_TX_DMA_CHANNEL, (uint16_t)length); //设置传输字节数
    DMA_Cmd(IIC1_TX_DMA_CHANNEL, ENABLE);    //打开DMA通道
    while( DMA_GetFlagStatus(DMA1_FLAG_TC6) == RESET);   //等待传输完成 
    DMA_Cmd(IIC1_TX_DMA_CHANNEL, DISABLE);     //关闭DMA通道  
    DMA_ClearFlag(DMA1_FLAG_TC6);   //清除DMA传输完成标志
}
```

但是没有预期的效果。。。

于是我又surf，又尝试注释掉上面`IIC1_DMA_TX(uint8_t *tx_buffer,uint16_t length)` 中的

```c
 while( DMA_GetFlagStatus(DMA1_FLAG_TC6) == RESET);   //等待传输完成 
 DMA_Cmd(IIC1_TX_DMA_CHANNEL, DISABLE);     //关闭DMA通道  
 DMA_ClearFlag(DMA1_FLAG_TC6);   //清除DMA传输完成标志
```

这三行代码后，在IIC_DMA中断函数中执行以下代码：

```c
void IIC1_DMA1_Channelx_IRQHandler(void)
{
    if(DMA_GetFlagStatus(DMA1_FLAG_TC6))
    {
	    //printf("\r\n\r\n000000000000000000\r\n\r\n");
	    DMA_ClearFlag(DMA1_FLAG_TC6);
	    //printf("\r\n\r\n1111111111111111111\r\n\r\n");
	    I2C_GenerateSTOP(IIC1_DMA, ENABLE);//关闭I2C1总线
	    //printf("\r\n\r\n2222222222222222222\r\n\r\n");
    }
}
```

让你失望了，这次也没能成功。。。

于是，我printf打印信息，查看代码卡在了哪个地方，结果卡在了第二次执行`OLED_SetPos(0,0);` 这个地方。。。OK，与OLED的显示原理有关，OLED到底是怎样显示字符的？OLED是怎样控制字符显示位置的？为什么循环设置同一位置不行？OLED刷新速率多快？对于这些，我在之前是没有概念的。所以还是那句话，没有掌握工作原理和明晰其工作情况的情况下，尝试去分析和解决问题是不切实际的。。。于是，这个部分被搁浅下来。

## PID调速

        结合商家例程，我很快完成了代码编写，但在调节pid参数上，花费了不少时间。这一部分的问题在上面已大篇幅提到。也正是因为对编码器计数存在疑问和不解，加之对pid调参的盲目性，导致出现的问题都是碰运气凭猜测尝试解决，却并未得到实际解决。

### 蓝牙调参

        由于使用的是之前的蓝牙模块，不知道其型号，无法查阅其配套手册，在配置蓝牙模块即AT指令这里我就遇到了麻烦。首先是AT指令错误。利用现有资料和网上资料，我尝试并整理出了其基础的蓝牙AT指令，能满足需求了，也花了一点时间，但也算可以了。然后我单独测试蓝牙与电脑的连接与通信，也是经过多次尝试和请教同学后完成了测试。但最大的问题是我不知道怎么连线（有被自己菜得笑到）。即蓝牙模块、单片机、电脑这三者怎么连接？测试时我用的是USB转TTL模块与蓝牙模块连接并使用串口调试助手与电脑通信的。后来换成最小系统与蓝牙模块连接并使用USART1与电脑进行蓝牙通信后就不行了。？？？不懂，单片机的USART1不是默认与CH340转串口模块连接的吗，电脑不是默认通过USART1来烧录程序给单片机的吗？道理是一样的吧。还有可以用单片机的USART2来与蓝牙模块连接吗？

## 最后的问题

        在这所有问题当中，最大的问题是如何让这个电机控制系统各功能同时运行起来？在最初的电机驱动和电机转速曲线两部分的同时实现就碰到了这样的问题。我尝试过使用定时器中断来控制电机转速的改变，在主函数while(1)循环里实现转速曲线的显示。但实践发现，由于定时器定时时间较短而转速曲线的显示又有延时的要求，所以往往在转速曲线显示程序还未执行完时就频繁进入中断，使得转速曲线显示部分理论上行得通，实际上不可行。在同学的提示下，我采用的DMA方式来实现转速曲线显示部分，仅需在中断函数中使能串口DMA传输，使得单片机能在同一时间既完成pwm调速又实现转速曲线显示。而OLED显示，蓝牙调参理论上均可通过此方式来实现。

## 个人感思

        好吧，我这并算不上学习总结，而是问题总结，问题多多没有解决。那就顺便梳理一下问题和所要继续学习的内容：

1.强制类型转换的原理；

2.OLED显示原理和像素与数据位的对应关系；

3.pid各参数作用和多次尝试；

4.蓝牙模块；

5.正在学习和将要学习的。

        其实，在这个过程中，给我感受最深的并不是个人能力的提升，而是对我学习方法和个人心态的一次考验和锻炼。实话说我花的时间并不少，可成效却甚微，这让我开始怀疑我的学习方法和心态是不是有点问题。首先，经验的匮乏以及有些东西初次接触让我无意识地处于一种自我怀疑的状态下；再者，当我们因为要使用一个东西而去学习它时和单纯地去学习它时的心态是不一样的，特别是还有时间限制的时候，至少对我自己来说是这样的。前者会让我迫切想要开始应用它而忽略掉自己一时间没弄明白的地方，而往往这些地方就是我们需要掌握的核心。核心没弄懂，应用自然谈不上顺利。最后就是在分析问题和解决问题上，还需要不断练习与实践，积累经验。而且，在频繁碰到问题，心态渐趋烦躁的时候，要平和心态，不要钻牛角尖，这样问题不仅得不到解决，人也会变得很丧。。。

最后的最后，keep learning。。。






